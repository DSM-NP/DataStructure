## 배열 - Array

> 배열은 **종류가 같은 여러 개의 데이터**를 저장하고 관리하기 위해서 사용되는 데이터 타입.

```java
// Java
String[] fruits = new String[4];
```

- 배열은 인덱스와 값이 쌍으로 이루어져 있다.

  ![ㅇ](https://github.com/DSM-NP/DataStructure/assets/103401813/cd272cf1-d32d-4c6a-b312-9952d21cdeb7)


  - 인덱스(Index): 어떤 값에 접근하기 위해 필요한 것
  - 값(Value): 배열 안에 실제 값

- 배열을 선언하면 컴퓨터에 메모리가 4 만큼의 공간을 할당 시켜 사용자가 사용할 수 있도록 한다.

- 배열은 메모리상에서 고정된 크기로 연속된 공간을 가지기 때문에 한 번 생성된 배열의 크기는 변경이 불가능하다. 그래서 처음 배열의 크기를 지정할 때 메모리를 낭비하지 않도록 적절히 지정해줘야 한다.

<img width="828" alt="스크린샷 2023-12-11 오후 2 14 12" src="https://github.com/DSM-NP/DataStructure/assets/103401813/8a7fd7cc-2578-48c7-8e8c-ef36167c28ac">

![Untitled](https://github.com/DSM-NP/DataStructure/assets/103401813/22aefdf1-2c07-472a-87af-c35ab0e27ca3)



------

### 원시타입 배열과 참조타입 배열

자바에서 데이터 타입을 원시타입(PrimitiveType)과 참조타입(Reference Type)으로 크게 두 가지로 분리되는데 타입에 따라 배열 선언 시 초기 설정 값이 다르다.

![메모리](https://github.com/DSM-NP/DataStructure/assets/103401813/0cc107ea-d81c-4d47-934d-6efe068dda79)


**원시타입(PrimitiveType) 배열**

> 원시타입은 정수, 실수, 문자, 논리 리터럴등의 **실제 데이터 값**을 저장하는 타입.

- 원시타입으로 배열이 초기화 될 때 Type별로 설정 된 기본 값으로 초기화된다.
  ![원시타입 배열](https://github.com/DSM-NP/DataStructure/assets/103401813/6c9dcd54-1619-48cf-8b9e-53e3946cafc1)
  

참조**타입(Reference Type) 배열**

> 참조타입은 **객체의 번지**를 참조(주소를 저장)하는 타입으로 메모리 번지 값을 통해 객체를 참조하는 타입.

- 참조타입으로 배열이 초기화 될 때 null로 초기화된다.

------

### 배열의 시간복잡도

<aside> 💡 사용자는 배열의 **인덱스를 통해 값에 접근** 할 수 있고 컴퓨터는 배열의 인덱스를 통해 메모리 주소를 알 수 있어 배열의 원소에 접근할 때 **시간 복잡도는 O(1)**이다.

→ 배열은 어떤 값에 접근하든 동일한 시간이 걸린다.

<img width="563" alt="스크린샷 2023-12-11 오후 5 32 00" src="https://github.com/DSM-NP/DataStructure/assets/103401813/cc48a60e-e750-46d4-9c96-9a239b26fc35">

- 배열 인덱스는 0부터 시작이다.

- 배열이 인덱스를 참조하여 값에 접근할 때 (데이터형의 크기) * (인덱스)만큼의 주소를 건너뛰어서 값에 접근하기 때문에 week[1]이런식으로 접근하지 않고(week + 2)와 같은 방식으로도 접근이 가능하다

  → C언어의 포인터를 배우면 이해하기 쉽다.

</aside>

------

### 배열의 특징

- 배열 생성 시 크기를 정해야 한다.
  - 배열에 담은 데이터의 수가 정확하지 않다면 크기를 크게 잡아 메모리를 낭비하거나 작게 잡으면 원하는 만큼의 데이터를 못 담은 상황이 발생한다.
- 배열 중간에 데이터를 삽입하거나 제거해야하는 경우가 발생 시 배열의 경우 변경만 가능하다.
- 배열의 원소 값을 중복없이 관리하기 어렵다.

------

### 다차원 배열

> 다차원 배열은 **2차원 이상의 배열**이고 배열 요소로 또 다른 배열을 가지는 배열을 의미한다.

![배열](https://github.com/DSM-NP/DataStructure/assets/103401813/cce466b0-2e0e-4298-9af0-77d7c2b4d004)

<img width="676" alt="스크린샷 2023-12-12 오후 12 18 22" src="https://github.com/DSM-NP/DataStructure/assets/103401813/fe79cfe9-63c1-49b2-9075-c5839e03e52b">
- 1차원 배열이 여러 개 모인 것
- 배열의 요소로 또다른 배열을 가지고 있다.
- 원하는 차원의 수 만큼 배열 기호([])를 추가하면 된다.


**2차원 배열**

<aside> 💡 2차원 배열은 인덱스를 2개 가지는 배열이다. 시간표와 같은 형태로 **행(row)과 열(column)**으로 나누게 된다.

<img width="230" alt="스크린샷 2023-12-12 오후 12 16 53" src="https://github.com/DSM-NP/DataStructure/assets/103401813/4ff717c1-7fb3-4eb7-bac0-57ec07be0256">


</aside>

```java
// Java
int [] arrayNum01 = new int[3]; // 선언과 동시에 배열 크기 지정 
// 배열이름[세로 인덱스(행)][가로 인덱스(열)]

int [] arrayNum02;
arrayNum02 = new int[3]; // 선언 후 크기 지정

int numArr[3][4] = {
    { 가로 요소 4개 },
    { 가로 요소 4개 },
    { 가로 요소 4개 }
}; // 행 3줄 열 4개
```

**2차원 배열의 표현 방법**

- 열 우선 순위(column major order)

- 행 우선 순위(row major order)
![행우선순우](https://github.com/DSM-NP/DataStructure/assets/103401813/492145d3-5160-4fb4-83c5-8bb0442ae8a7)


3차원, 4차원 배열등과 같이 다차원 배열들은 차원 수에 맞게 인덱스만 추가하고 주소 계산법 또한 동일하다.

- 3차원 배열에는  첫 번째 인덱스인 면을 기준을 하는 방법이고 마지막 인덱스인 열을 기준으로 하는 열 우선 순서 방법이 있다.

  - 면 우선 순위 ex) array[0][0][1], array[0][0][2]

  - 열 우선 순위 ex) array[0][0][0], array[1][0][0], array[0][1][0], array[1][1][0]
    ![열 우선 순위](https://github.com/DSM-NP/DataStructure/assets/103401813/a9b1b7bc-9f67-47d1-a6e5-83a645e88e8d)


------

### 2차원 배열 크기 다르게 지정하기

```java
int [][] arrayNum = new int[3][];

arrayNum[0] = new int[5];
arrayNum[1] = new int[3];
arrayNum[2] = new int[4];
```

2차원 배열 선언 시 **1차원 배열의 크기만 먼저 지정가능**하다. 배열 길이의 앞부분 정수는 배열의 주소를 관리하기 때문에 반드시 지정해줘야 한다. 하지만 뒷 부분 정수는 각 인덱스에 배열의 길이이기 때문에 선언 시 반드시 지정해줄 필요는 없다. 그래서 **위 코드와 같은 방법으로 1차원 배열의 각 인덱스에 대한 각각 다른 크기의 배열을 선언할 수 있다.**

- 정변 배열 : 서로 같은 길이의 여러 개 배열을 하나로 묶어 관리하는 2차원 배열
- 가변 배열 : 서로 다른 길이의 여러 개의 배열을 하나로 묶어 관리하는 2차원 배열
![가변](https://github.com/DSM-NP/DataStructure/assets/103401813/e5725e20-d2b2-43c4-a4cf-d2bdb4323a52)


위의 코드처럼 선언 시 0번 인덱스에는 최대 5개의 값만 저장가능하고 1번 인덱에는 최대 3개, 2번 인덱스는 최대 4개의 값만 저장가능하다.
